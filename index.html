<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STC Circuit Assurance</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f7f8fb;
      --card: #ffffff;
      --border: #d9dde6;
      --text: #1b2430;
      --muted: #5b677a;
      --primary: #4f008c;
      --accent: #ff375e;
      --success: #1f9254;
      --warning: #d9822b;
      --danger: #c0342f;
      --lock: #8d99ae;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 24px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }

    p.lead {
      margin: 0 0 20px;
      color: var(--muted);
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(24, 32, 50, 0.08);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 0.9rem;
    }

    input, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
    }

    input:focus, select:focus {
      outline: 2px solid rgba(79, 0, 140, 0.25);
      border-color: var(--primary);
    }

    .helper {
      color: var(--muted);
      font-size: 0.8rem;
      margin-top: 4px;
    }

    .error {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 4px;
    }

    .inline {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid transparent;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: white;
    }

    button:hover:not(:disabled) {
      background: #3c006b;
    }

    button.secondary {
      background: white;
      border-color: var(--border);
      color: var(--text);
    }

    button.secondary:hover:not(:disabled) {
      border-color: var(--primary);
      color: var(--primary);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    .summary-item {
      padding: 10px 12px;
      border-radius: 8px;
      background: #f0f3fa;
      font-size: 0.85rem;
    }

    .summary-item strong {
      display: block;
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .command-list {
      display: grid;
      gap: 12px;
    }

    .command-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px 14px;
      display: grid;
      gap: 10px;
    }

    .command-card.locked {
      background: #f8f9fc;
      border-style: dashed;
      color: var(--lock);
    }

    .command-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .status {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      padding: 4px 8px;
      border-radius: 999px;
    }

    .status.ready {
      background: rgba(79, 0, 140, 0.12);
      color: var(--primary);
    }

    .status.locked {
      background: rgba(141, 153, 174, 0.2);
      color: var(--lock);
    }

    .status.copied {
      background: rgba(255, 55, 94, 0.18);
      color: var(--accent);
    }

    .command-text {
      font-family: var(--mono);
      font-size: 0.95rem;
      padding: 10px 12px;
      background: #f3f4f8;
      border-radius: 8px;
      overflow-x: auto;
    }

    .locked-message {
      font-size: 0.85rem;
      color: var(--lock);
    }

    .progressive-fields {
      display: grid;
      gap: 12px;
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed var(--border);
      background: #fbfbfd;
    }

    .small-tag {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .not-implemented {
      border-left: 4px solid var(--accent);
      background: #fff7ed;
      color: #7a4c1b;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      margin-top: 10px;
    }

    @media (max-width: 600px) {
      body {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>STC Circuit Assurance</h1>
    <p class="lead">Operational checks made simple—copy one command at a time.</p>

    <div class="card">
      <h2>Inputs</h2>
      <div class="form-grid">
        <div>
          <label for="circuitName">Circuit Name *</label>
          <input id="circuitName" placeholder="JEDDAH-MAKKAH IP263" style="text-transform: uppercase;" />
          <div class="helper">Format: &lt;SITE-A&gt;-&lt;SITE-Z&gt; &lt;TYPE&gt;&lt;ID&gt;</div>
          <div class="error" data-error-for="circuitName"></div>
        </div>
        <div>
          <label for="orderType">Order Type *</label>
          <select id="orderType">
            <option value="">Select</option>
            <option value="I">I</option>
            <option value="M">M</option>
            <option value="C">C</option>
            <option value="O">O</option>
          </select>
          <div class="error" data-error-for="orderType"></div>
        </div>
        <div>
          <label for="transportType">Transport Type *</label>
          <select id="transportType">
            <option value="">Select</option>
            <option value="Fiber">Fiber</option>
            <option value="Copper">Copper</option>
            <option value="Transmission">Transmission</option>
            <option value="UPE">UPE</option>
          </select>
          <div class="error" data-error-for="transportType"></div>
        </div>
        <div>
          <label for="aggVendor">Aggregator PE Vendor *</label>
          <select id="aggVendor">
            <option value="">Select</option>
            <option value="Cisco">Cisco</option>
            <option value="Huawei">Huawei</option>
            <option value="Juniper">Juniper</option>
          </select>
          <div class="error" data-error-for="aggVendor"></div>
        </div>
        <div>
          <label for="aggregatorPe">Aggregator PE Name *</label>
          <input id="aggregatorPe" placeholder="AGG-PE-01" />
          <div class="error" data-error-for="aggregatorPe"></div>
        </div>
        <div id="upeNameField" style="display: none;">
          <label for="upeName">UPE Name (required if UPE)</label>
          <input id="upeName" placeholder="UPE-01" />
          <div class="error" data-error-for="upeName"></div>
        </div>
        <div>
          <label for="vlanId">VLAN ID *</label>
          <input id="vlanId" type="number" min="1" max="4094" />
          <div class="error" data-error-for="vlanId"></div>
        </div>
        <div id="interfaceField">
          <label for="interfaceName">Interface (optional)</label>
          <input id="interfaceName" placeholder="Bundle-Ether10.263" />
          <div class="helper">Required to unlock interface-dependent commands.</div>
        </div>
        <div id="upeVendorField" style="display: none;">
          <label for="upeVendor">UPE Vendor (required if UPE)</label>
          <select id="upeVendor">
            <option value="">Select</option>
            <option value="Cisco">Cisco</option>
            <option value="Huawei">Huawei</option>
            <option value="Juniper">Juniper</option>
          </select>
          <div class="error" data-error-for="upeVendor"></div>
        </div>
        <div>
          <label for="customerIp">Customer IP (Layer 3) *</label>
          <input id="customerIp" placeholder="192.0.2.10" />
          <div class="error" data-error-for="customerIp"></div>
        </div>
        <div>
          <label for="defaultGateway">Default Gateway (Layer 3) *</label>
          <input id="defaultGateway" placeholder="192.0.2.1" />
          <div class="error" data-error-for="defaultGateway"></div>
        </div>
        <div>
          <label for="vrfName" id="vrfLabelText">VRF Name *</label>
          <input id="vrfName" placeholder="VRF-Example" />
          <div class="helper" id="vrfLabel">Cisco: VRF Name</div>
          <div class="error" data-error-for="vrfName"></div>
        </div>
        <div id="juniperFields" style="display: none;">
          <label for="juniperPlacement">Juniper L3 Circuit Placement *</label>
          <select id="juniperPlacement">
            <option value="">Select</option>
            <option value="vlan">Configured under VLAN unit (ae/ge unit = VLAN)</option>
            <option value="irb">Configured under IRB unit (BVI equivalent)</option>
          </select>
          <div class="error" data-error-for="juniperPlacement"></div>
        </div>
        <div id="juniperIfaceField" style="display: none;">
          <label for="juniperIfaceBase">Juniper L3 Interface Base (Option A)</label>
          <input id="juniperIfaceBase" placeholder="ae462 or ge-100/0/25" />
          <div class="helper">Required when placement is VLAN unit. No spaces.</div>
          <div class="error" data-error-for="juniperIfaceBase"></div>
        </div>
        <div id="juniperIrbField" style="display: none;">
          <label for="irbUnitId">IRB Unit ID (Option B)</label>
          <input id="irbUnitId" placeholder="10737" />
          <div class="helper">Required when placement is IRB unit. Digits only.</div>
          <div class="error" data-error-for="irbUnitId"></div>
        </div>
      </div>
      <div class="card" style="margin-top: 16px;">
        <h2>Layer Determination</h2>
        <div id="layerInfo" class="helper">Layer is inferred from circuit token.</div>
        <div id="layerOverride" class="inline" style="margin-top: 10px; display: none;">
          <strong>Manual Override:</strong>
          <label><input type="radio" name="layerChoice" value="L2"> Layer 2</label>
          <label><input type="radio" name="layerChoice" value="L3"> Layer 3</label>
        </div>
        <div class="error" data-error-for="layerChoice"></div>
      </div>
      <div class="buttons" style="margin-top: 16px;">
        <button id="generate">Build Command Runner</button>
        <button id="reset" class="secondary">Reset Form</button>
        <button id="download" class="secondary" disabled>Download All Commands (.txt)</button>
      </div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Classification Summary</h2>
      <div id="summary" class="summary-grid"></div>
      <div id="notImplemented" class="not-implemented" style="display: none;"></div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Command Runner</h2>
      <div id="commandRunner" class="command-list"></div>
      <div id="escalationNote" class="helper" style="margin-top: 12px; display: none;"></div>
    </div>
  </div>

  <script>
    const state = {
      inputs: {
        circuitName: "",
        orderType: "",
        transportType: "",
        aggregatorPe: "",
        upeName: "",
        vlanId: "",
        interfaceName: "",
        aggVendor: "",
        upeVendor: "",
        customerIp: "",
        defaultGateway: "",
        vrfName: "",
        juniperPlacement: "",
        juniperIfaceBase: "",
        irbUnitId: "",
        layerChoice: "",
        bridgeGroup: "",
        bridgeDomain: "",
        cpuLocationChoice: "",
        cpuLocationManual: "",
        bviId: ""
      },
      derived: {
        parsedCircuit: null,
        inferredLayer: "",
        layerSource: ""
      },
      progress: {
        copied: {},
        revealBridge: false,
        revealL2Bd: false
      }
    };

    const fieldIds = Object.keys(state.inputs);

    function parseCircuitName(value) {
      if (!value) return null;
      const cleaned = value.trim().toUpperCase();
      const match = cleaned.match(/^([A-Z0-9]+)-([A-Z0-9]+)\s+([A-Z]+)(\d+)$/);
      if (!match) return null;
      return {
        siteA: match[1],
        siteZ: match[2],
        serviceToken: match[3],
        serviceId: match[4],
        fullToken: `${match[3]}${match[4]}`
      };
    }

    function inferLayer(serviceToken) {
      if (!serviceToken) return "";
      const token = serviceToken.toUpperCase();
      if (["IP", "SIP"].includes(token)) return "L3";
      if (["DIA", "DIAS", "PLL", "DLL", "MDIA"].includes(token)) return "L2";
      return "UNKNOWN";
    }

    function validateIPv4(value) {
      const parts = value.trim().split(".");
      if (parts.length !== 4) return false;
      return parts.every(part => {
        if (!/^\d+$/.test(part)) return false;
        const num = Number(part);
        return num >= 0 && num <= 255;
      });
    }

    function setError(field, message) {
      const el = document.querySelector(`[data-error-for="${field}"]`);
      if (el) {
        el.textContent = message || "";
      }
    }

    function syncInputs() {
      fieldIds.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        state.inputs[id] = el.value.trim();
      });
      const choice = document.querySelector('input[name="layerChoice"]:checked');
      state.inputs.layerChoice = choice ? choice.value : "";
    }

    function updateDerived() {
      const parsed = parseCircuitName(state.inputs.circuitName);
      state.derived.parsedCircuit = parsed;
      if (parsed) {
        const inferred = inferLayer(parsed.serviceToken);
        state.derived.inferredLayer = inferred;
      } else {
        state.derived.inferredLayer = "";
      }
    }

    function determineLayer() {
      if (state.derived.inferredLayer && state.derived.inferredLayer !== "UNKNOWN") {
        state.derived.layerSource = "inferred";
        return state.derived.inferredLayer;
      }
      if (state.derived.inferredLayer === "UNKNOWN" && state.inputs.layerChoice) {
        state.derived.layerSource = "manual";
        return state.inputs.layerChoice;
      }
      return "";
    }

    function validateAll() {
      syncInputs();
      updateDerived();
      const errors = {};
      if (!state.inputs.circuitName) {
        errors.circuitName = "Circuit name is required.";
      } else if (!state.derived.parsedCircuit) {
        errors.circuitName = "Circuit name format is invalid.";
      }

      if (!state.inputs.orderType) {
        errors.orderType = "Order type is required.";
      }
      if (!state.inputs.transportType) {
        errors.transportType = "Transport type is required.";
      }
      const needsAgg = ["Fiber", "Copper", "Transmission", "UPE"].includes(state.inputs.transportType);
      if (needsAgg && !state.inputs.aggregatorPe) {
        errors.aggregatorPe = "Aggregator PE name is required.";
      }
      if (state.inputs.transportType === "UPE" && !state.inputs.upeName) {
        errors.upeName = "UPE name is required for UPE transport.";
      }
      const vlan = Number(state.inputs.vlanId);
      if (!state.inputs.vlanId) {
        errors.vlanId = "VLAN ID is required.";
      } else if (!Number.isInteger(vlan) || vlan < 1 || vlan > 4094) {
        errors.vlanId = "VLAN must be between 1 and 4094.";
      }
      if (!state.inputs.aggVendor) {
        errors.aggVendor = "Aggregator PE vendor is required.";
      }
      if (state.inputs.transportType === "UPE" && !state.inputs.upeVendor) {
        errors.upeVendor = "UPE vendor is required for UPE transport.";
      }

      const layer = determineLayer();
      if (!layer) {
        errors.layerChoice = "Layer cannot be determined. Select a manual override.";
      }

      if (layer === "L3") {
        if (!state.inputs.customerIp) {
          errors.customerIp = "Customer IP is required for Layer 3.";
        } else if (!validateIPv4(state.inputs.customerIp)) {
          errors.customerIp = "Customer IP must be a valid IPv4 address.";
        }
        if (!state.inputs.defaultGateway) {
          errors.defaultGateway = "Default gateway is required for Layer 3.";
        } else if (!validateIPv4(state.inputs.defaultGateway)) {
          errors.defaultGateway = "Default gateway must be a valid IPv4 address.";
        }
        if (!state.inputs.vrfName) {
          errors.vrfName = "Routing context name is required for Layer 3.";
        }
      }

      if (state.inputs.aggVendor === "Juniper" && layer === "L3") {
        if (!state.inputs.juniperPlacement) {
          errors.juniperPlacement = "Select a Juniper placement option.";
        }
        if (state.inputs.juniperPlacement === "vlan") {
          if (!state.inputs.juniperIfaceBase) {
            errors.juniperIfaceBase = "Juniper interface base is required.";
          } else if (!/^[A-Za-z0-9/-]+$/.test(state.inputs.juniperIfaceBase)) {
            errors.juniperIfaceBase = "Interface base must not include spaces.";
          }
        }
        if (state.inputs.juniperPlacement === "irb") {
          if (!state.inputs.irbUnitId) {
            errors.irbUnitId = "IRB Unit ID is required.";
          } else if (!/^\d+$/.test(state.inputs.irbUnitId)) {
            errors.irbUnitId = "IRB Unit ID must be digits only.";
          }
        }
      }

      fieldIds.forEach(field => setError(field, ""));
      setError("layerChoice", "");
      Object.entries(errors).forEach(([field, message]) => setError(field, message));

      return {
        isValid: Object.keys(errors).length === 0,
        errors
      };
    }

    function normalizeHuaweiInterface(input) {
      const trimmed = (input || "").trim();
      if (!trimmed) return "";
      if (/^\\d+$/.test(trimmed)) {
        return `Eth-Trunk${trimmed}`;
      }
      return trimmed;
    }

    function resolveCpuLocation() {
      if (state.inputs.cpuLocationChoice === "unknown") {
        return "?";
      }
      if (state.inputs.cpuLocationChoice === "manual") {
        return (state.inputs.cpuLocationManual || "").trim();
      }
      return "";
    }

    function buildCiscoL3Commands() {
      const parsed = state.derived.parsedCircuit;
      if (!parsed) return [];
      const fullToken = parsed.fullToken;
      const interfaceName = state.inputs.interfaceName;
      const vrf = state.inputs.vrfName;
      const customerIp = state.inputs.customerIp;
      const bridgeGroup = state.inputs.bridgeGroup || "";
      const bridgeDomain = state.inputs.bridgeDomain || "";
      const bviId = state.inputs.bviId || "";
      const aggregatorPe = state.inputs.aggregatorPe || "";

      return [
        {
          id: 0,
          label: "Step 0",
          template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
          requires: ["aggregator"]
        },
        {
          id: 1,
          label: "Step 1",
          template: `sh int desc | i ${fullToken}`,
          requires: []
        },
        {
          id: 2,
          label: "Step 2",
          template: interfaceName ? `sh run int ${interfaceName}` : "sh run int <INTERFACE>",
          requires: ["interface"]
        },
        {
          id: 3,
          label: "Step 3",
          template: interfaceName
            ? `sh l2vpn bridge-domain interface ${interfaceName} brief`
            : "sh l2vpn bridge-domain interface <INTERFACE> brief",
          requires: ["interface"]
        },
        {
          id: 4,
          label: "Step 4",
          template: bridgeGroup && bridgeDomain
            ? `sh run l2vpn bridge group ${bridgeGroup} bridge-domain ${bridgeDomain}`
            : "sh run l2vpn bridge group <BRIDGE_GROUP> bridge-domain <BRIDGE_DOMAIN>",
          requires: ["bridge"]
        },
        {
          id: 5,
          label: "Step 5",
          template: bviId ? `sh run int BVI${bviId}` : "sh run int BVI<BVI_ID>",
          requires: ["bvi"]
        },
        {
          id: 6,
          label: "Step 6",
          template: vrf && customerIp
            ? `sh arp vrf ${vrf} ${customerIp}`
            : "sh arp vrf <VRF> <CUSTOMER_IP>",
          requires: ["vrf"]
        },
        {
          id: 7,
          label: "Step 7",
          template: vrf && customerIp
            ? `ping vrf ${vrf} ${customerIp} count 100`
            : "ping vrf <VRF> <CUSTOMER_IP> count 100",
          requires: ["vrf"]
        },
        {
          id: 8,
          label: "Step 8",
          template: vrf && customerIp
            ? `show bgp vrf ${vrf} summary | i ${customerIp}`
            : "show bgp vrf <VRF> summary | i <CUSTOMER_IP>",
          requires: ["vrf"]
        }
      ];
    }

    function buildHuaweiL3Commands() {
      const vlanId = state.inputs.vlanId;
      const interfaceName = normalizeHuaweiInterface(state.inputs.interfaceName);
      const vpnInstance = state.inputs.vrfName;
      const customerIp = state.inputs.customerIp;
      const aggregatorPe = state.inputs.aggregatorPe || "";

      return [
        {
          id: 0,
          label: "Step 0",
          template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
          requires: ["aggregator"]
        },
        {
          id: 1,
          label: "Step 1",
          template: vlanId ? `dis cur int vl ${vlanId}` : "dis cur int vl <VLAN_ID>",
          requires: ["vlan"]
        },
        {
          id: 2,
          label: "Step 2",
          template: vlanId ? `dis mac-address dynamic vlan ${vlanId}` : "dis mac-address dynamic vlan <VLAN_ID>",
          requires: ["vlan"]
        },
        {
          id: 3,
          label: "Step 3",
          template: vlanId && interfaceName
            ? `display current-configuration interface ${interfaceName} | i ${vlanId}`
            : "display current-configuration interface <INTERFACE> | i <VLAN_ID>",
          requires: ["vlan", "interfaceHuawei"]
        },
        {
          id: 4,
          label: "Step 4",
          template: vpnInstance && customerIp
            ? `ping -c 10 -vpn-instance ${vpnInstance} ${customerIp}`
            : "ping -c 10 -vpn-instance <VPN_INSTANCE> <CUSTOMER_IP>",
          requires: ["vpn"]
        },
        {
          id: 5,
          label: "Step 5",
          template: vpnInstance && customerIp
            ? `display bgp vpnv4 vpn-instance ${vpnInstance} peer | i ${customerIp}`
            : "display bgp vpnv4 vpn-instance <VPN_INSTANCE> peer | i <CUSTOMER_IP>",
          requires: ["vpn"]
        }
      ];
    }

    function buildJuniperL3Commands() {
      const vlanId = state.inputs.vlanId;
      const customerIp = state.inputs.customerIp;
      const routingInstance = state.inputs.vrfName;
      const ifaceBase = state.inputs.juniperIfaceBase;
      const irbUnitId = state.inputs.irbUnitId;
      const placement = state.inputs.juniperPlacement;
      const aggregatorPe = state.inputs.aggregatorPe || "";
      const riConfigName = state.inputs.vrfName;

      if (placement === "vlan") {
        return [
          {
            id: 0,
            label: "Step 0",
            template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
            requires: ["aggregator"]
          },
          {
            id: 1,
            label: "Step 1 • VLAN config match",
            template: vlanId ? `show configuration | display set | match ${vlanId}` : "show configuration | display set | match <VLAN_ID>",
            requires: ["vlan"]
          },
          {
            id: 2,
            label: "Step 2 • PING",
            template: routingInstance && customerIp
              ? `ping routing-instance ${routingInstance} ${customerIp} rapid count 100`
              : "ping routing-instance <ROUTING_INSTANCE> <CUSTOMER_IP> rapid count 100",
            requires: ["juniperPing"]
          },
          {
            id: 3,
            label: "Step 3 • ARP",
            template: ifaceBase && vlanId
              ? `show arp no-resolve interface ${ifaceBase}.${vlanId}`
              : "show arp no-resolve interface <IFACE_BASE>.<VLAN_ID>",
            requires: ["juniperIface", "vlan"]
          },
          {
            id: 8,
            label: "Step 8 • RI config",
            template: riConfigName
              ? `show configuration routing-instances ${riConfigName}`
              : "show configuration routing-instances <RI_CONFIG_NAME>",
            requires: ["juniperRi"]
          }
        ];
      }

      if (placement === "irb") {
        return [
          {
            id: 0,
            label: "Step 0",
            template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
            requires: ["aggregator"]
          },
          {
            id: 4,
            label: "Step 4 • IRB config match",
            template: irbUnitId
              ? `show configuration | display set | match ${irbUnitId}`
              : "show configuration | display set | match <IRB_UNIT_ID>",
            requires: ["juniperIrb"]
          },
          {
            id: 5,
            label: "Step 5 • ARP",
            template: irbUnitId
              ? `show arp no-resolve interface irb.${irbUnitId}`
              : "show arp no-resolve interface irb.<IRB_UNIT_ID>",
            requires: ["juniperIrb"]
          },
          {
            id: 6,
            label: "Step 6 • PING",
            template: routingInstance && customerIp
              ? `ping routing-instance ${routingInstance} ${customerIp} count 100 rapid`
              : "ping routing-instance <ROUTING_INSTANCE> <CUSTOMER_IP> count 100 rapid",
            requires: ["juniperPing"]
          },
          {
            id: 7,
            label: "Step 7 • BGP",
            template: customerIp
              ? `show bgp summary | match ${customerIp}`
              : "show bgp summary | match <CUSTOMER_IP>",
            requires: ["juniperBgp"]
          },
          {
            id: 8,
            label: "Step 8 • RI config",
            template: riConfigName
              ? `show configuration routing-instances ${riConfigName}`
              : "show configuration routing-instances <RI_CONFIG_NAME>",
            requires: ["juniperRi"]
          }
        ];
      }

      return [];
    }

    function buildCiscoL2Commands() {
      const l2DisplayName = state.inputs.circuitName;
      const interfaceName = state.inputs.interfaceName;
      const bdName = state.inputs.bridgeDomain;
      const bridgeGroup = state.inputs.bridgeGroup;
      const cpuLocation = resolveCpuLocation();
      const bridgeDomain = state.inputs.bridgeDomain;
      const aggregatorPe = state.inputs.aggregatorPe || "";

      return [
        {
          id: 0,
          label: "Step 0",
          title: "Connect",
          template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
          requires: ["aggregator"]
        },
        {
          id: 1,
          label: "Step 1",
          title: "Find Interface",
          template: l2DisplayName
            ? `show interfaces description | i ${l2DisplayName}`
            : "show interfaces description | i <CIRCUIT_NAME>",
          requires: ["circuitNameL2"]
        },
        {
          id: 2,
          label: "Step 2",
          title: "Check Interface Config",
          template: interfaceName
            ? `sho running-config interface ${interfaceName}`
            : "sho running-config interface <INTERFACE>",
          requires: ["interface"]
        },
        {
          id: 3,
          label: "Step 3",
          title: "BD Summary",
          template: interfaceName
            ? `sho l2vpn bridge-domain interface ${interfaceName} brief`
            : "sho l2vpn bridge-domain interface <INTERFACE> brief",
          requires: ["interface"]
        },
        {
          id: 4,
          label: "Step 4",
          title: "MAC Table",
          template: bdName && bridgeGroup && cpuLocation
            ? `show l2vpn forwarding bridge-domain ${bridgeGroup}:${bdName} mac-address location ${cpuLocation}`
            : "show l2vpn forwarding bridge-domain <BRIDGE_GROUP>:<BRIDGE_DOMAIN> mac-address location <CPU_LOCATION>",
          requires: ["l2Bd", "l2Cpu"]
        },
        {
          id: 5,
          label: "Step 5",
          title: "BD Config",
          template: bridgeGroup && bridgeDomain
            ? `sh run l2vpn bridge group ${bridgeGroup} bridge-domain ${bridgeDomain}`
            : "sh run l2vpn bridge group <BRIDGE_GROUP> bridge-domain <BRIDGE_DOMAIN>",
          requires: ["l2Bridge"]
        },
        {
          id: 6,
          label: "Step 6",
          title: "PE Loopback",
          template: "sh run int lo0",
          requires: []
        }
      ];
    }

    function buildCommandModel() {
      const layer = determineLayer();
      if (state.inputs.aggVendor === "Cisco" && layer === "L3") {
        return buildCiscoL3Commands();
      }
      if (state.inputs.aggVendor === "Cisco" && layer === "L2") {
        return buildCiscoL2Commands();
      }
      if (state.inputs.aggVendor === "Huawei" && layer === "L3") {
        return buildHuaweiL3Commands();
      }
      if (state.inputs.aggVendor === "Juniper" && layer === "L3") {
        return buildJuniperL3Commands();
      }
      return [];
    }

    function isLocked(command) {
      if (command.requires.includes("aggregator") && !state.inputs.aggregatorPe) {
        return { locked: true, reason: "Aggregator PE name is required to unlock this command." };
      }
      if (command.requires.includes("vlan") && !state.inputs.vlanId) {
        return { locked: true, reason: "Provide VLAN ID to unlock this command." };
      }
      if (command.requires.includes("interface") && !state.inputs.interfaceName) {
        return { locked: true, reason: "Interface not provided — add interface to unlock this command." };
      }
      if (command.requires.includes("interfaceHuawei") && !state.inputs.interfaceName) {
        return { locked: true, reason: "Interface not provided — add Eth-Trunk interface to unlock this command." };
      }
      if (command.requires.includes("circuitNameL2") && !state.inputs.circuitName) {
        return { locked: true, reason: "Provide circuit name to unlock this command." };
      }
      if (command.requires.includes("l2Bd")) {
        if (!state.progress.revealL2Bd) {
          return { locked: true, reason: "Copy Step 3 to unlock Bridge Group/Domain inputs." };
        }
        if (!state.inputs.bridgeGroup || !state.inputs.bridgeDomain) {
          return { locked: true, reason: "Provide Bridge Group and Bridge Domain to unlock this command." };
        }
      }
      if (command.requires.includes("l2Cpu")) {
        if (!state.inputs.bridgeGroup || !state.inputs.bridgeDomain) {
          return { locked: true, reason: "Provide Bridge Group and Bridge Domain to unlock MAC check." };
        }
        if (!resolveCpuLocation()) {
          return { locked: true, reason: "Select a MAC location option to run MAC table check." };
        }
      }
      if (command.requires.includes("l2Bridge")) {
        if (!state.inputs.bridgeGroup || !state.inputs.bridgeDomain) {
          return { locked: true, reason: "Provide Bridge Group and Bridge Domain to unlock this command." };
        }
      }
      if (command.requires.includes("bridge")) {
        if (!state.inputs.bridgeGroup || !state.inputs.bridgeDomain) {
          return { locked: true, reason: "Provide Bridge Group + Bridge Domain to unlock." };
        }
      }
      if (command.requires.includes("bvi") && !state.inputs.bviId) {
        return { locked: true, reason: "Optional: provide BVI ID to unlock this command." };
      }
      if (command.requires.includes("vrf")) {
        if (!state.inputs.vrfName || !state.inputs.customerIp) {
          return { locked: true, reason: "Provide VRF and Customer IP to unlock." };
        }
      }
      if (command.requires.includes("vpn")) {
        if (!state.inputs.vrfName || !state.inputs.customerIp) {
          return { locked: true, reason: "Provide VPN Instance and Customer IP to unlock." };
        }
      }
      if (command.requires.includes("juniperIface")) {
        if (!state.inputs.juniperIfaceBase) {
          return { locked: true, reason: "Provide Juniper interface base (e.g., ae462) to unlock ARP check." };
        }
      }
      if (command.requires.includes("juniperIrb")) {
        if (!state.inputs.irbUnitId) {
          return { locked: true, reason: "Provide IRB Unit ID to unlock this command." };
        }
      }
      if (command.requires.includes("juniperPing")) {
        if (!state.inputs.vrfName || !state.inputs.customerIp) {
          return { locked: true, reason: "Provide Routing Instance and Customer IP to unlock." };
        }
      }
      if (command.requires.includes("juniperBgp")) {
        if (!state.inputs.customerIp) {
          return { locked: true, reason: "Provide Customer IP to unlock." };
        }
      }
      if (command.requires.includes("juniperRi")) {
        if (!state.inputs.vrfName) {
          return { locked: true, reason: "Provide Routing Instance to unlock." };
        }
      }
      return { locked: false, reason: "" };
    }

    function renderSummary() {
      const parsed = state.derived.parsedCircuit;
      const layer = determineLayer();
      const summary = document.getElementById("summary");
      summary.innerHTML = "";
      const routingLabel = state.inputs.aggVendor === "Huawei"
        ? "VPN Instance"
        : state.inputs.aggVendor === "Juniper"
          ? "Routing Instance"
          : "VRF";
      const items = [
        { label: "Layer", value: layer || "—" },
        { label: "Order Type", value: state.inputs.orderType || "—" },
        { label: "Transport", value: state.inputs.transportType || "—" },
        { label: "Aggregator Vendor", value: state.inputs.aggVendor || "—" },
        { label: "UPE Vendor", value: state.inputs.upeVendor || "—" },
        { label: "Sites", value: parsed ? `${parsed.siteA} ↔ ${parsed.siteZ}` : "—" },
        { label: "Circuit Token", value: parsed ? parsed.fullToken : "—" },
        { label: "VLAN", value: state.inputs.vlanId || "—" },
        { label: routingLabel, value: state.inputs.vrfName || "—" }
      ];

      if (state.inputs.aggVendor === "Juniper" && layer === "L3") {
        const placementLabel = state.inputs.juniperPlacement === "vlan"
          ? "VLAN unit"
          : state.inputs.juniperPlacement === "irb"
            ? "IRB unit"
            : "—";
        items.push({ label: "Placement", value: placementLabel });
        if (state.inputs.juniperPlacement === "vlan") {
          const ifaceValue = state.inputs.juniperIfaceBase && state.inputs.vlanId
            ? `${state.inputs.juniperIfaceBase}.${state.inputs.vlanId}`
            : "—";
          items.push({ label: "Juniper Interface", value: ifaceValue });
        }
        if (state.inputs.juniperPlacement === "irb") {
          const irbValue = state.inputs.irbUnitId ? `irb.${state.inputs.irbUnitId}` : "—";
          items.push({ label: "IRB Interface", value: irbValue });
        }
        items.push({ label: "Customer IP", value: state.inputs.customerIp || "—" });
        items.push({ label: "RI Config Name", value: state.inputs.vrfName || "—" });
      }

      if (state.inputs.aggVendor === "Cisco" && layer === "L2") {
        items.push({ label: "Service Token", value: parsed ? parsed.serviceToken : "—" });
        items.push({ label: "Circuit Name", value: state.inputs.circuitName || "—" });
        if (state.inputs.interfaceName) {
          items.push({ label: "Interface", value: state.inputs.interfaceName });
        }
        if (state.inputs.bridgeDomain) {
          items.push({ label: "BD Name", value: state.inputs.bridgeDomain });
        }
      }
      items.forEach(item => {
        const div = document.createElement("div");
        div.className = "summary-item";
        div.innerHTML = `<strong>${item.label}</strong>${item.value}`;
        summary.appendChild(div);
      });
    }

    function renderCommandRunner(commands) {
      const runner = document.getElementById("commandRunner");
      runner.innerHTML = "";

      if (!commands.length) {
        runner.innerHTML = "<div class='helper'>No commands available yet. Build the runner after completing required inputs.</div>";
        return;
      }

      commands.forEach(command => {
        const statusInfo = isLocked(command);
        const isCopied = state.progress.copied[command.id];
        const card = document.createElement("div");
        card.className = `command-card ${statusInfo.locked ? "locked" : ""}`;
        card.dataset.commandId = command.id;

      const header = document.createElement("div");
      header.className = "command-header";
      const titleHtml = command.title ? `<span class="small-tag">${command.title}</span>` : "";
      header.innerHTML = `
          <div class="inline"><strong>${command.label}</strong>${titleHtml}</div>
          <div class="status ${isCopied ? "copied" : statusInfo.locked ? "locked" : "ready"}">
            ${isCopied ? "Copied ✓" : statusInfo.locked ? "Locked" : "Ready"}
          </div>
        `;

        const commandText = document.createElement("div");
        commandText.className = "command-text";
        commandText.textContent = command.template;

        const footer = document.createElement("div");
        footer.className = "inline";

        const copyButton = document.createElement("button");
        copyButton.textContent = "Copy";
        copyButton.disabled = statusInfo.locked;
        copyButton.addEventListener("click", () => handleCopy(command.id, command.template));

        const statusText = document.createElement("span");
        statusText.className = "small-tag";
        statusText.textContent = statusInfo.locked ? statusInfo.reason : "Command ready to copy.";

        footer.appendChild(copyButton);
        footer.appendChild(statusText);

        card.appendChild(header);
        card.appendChild(commandText);
        card.appendChild(footer);

        if (command.id === 3 && state.progress.revealBridge && state.inputs.aggVendor === "Cisco" && determineLayer() === "L3") {
          const bridgeWrap = document.createElement("div");
          bridgeWrap.className = "progressive-fields";
          bridgeWrap.innerHTML = `
            <div>
              <label for="bridgeGroup">Bridge Group *</label>
              <input id="bridgeGroup" placeholder="BG-EXAMPLE" value="${state.inputs.bridgeGroup || ""}" />
              <div class="error" data-error-for="bridgeGroup"></div>
            </div>
            <div>
              <label for="bridgeDomain">Bridge Domain *</label>
              <input id="bridgeDomain" placeholder="BD-EXAMPLE" value="${state.inputs.bridgeDomain || ""}" />
              <div class="error" data-error-for="bridgeDomain"></div>
            </div>
          `;
          card.appendChild(bridgeWrap);
        }

        if (command.id === 5 && state.inputs.aggVendor === "Cisco" && determineLayer() === "L3") {
          const bviWrap = document.createElement("div");
          bviWrap.className = "progressive-fields";
          bviWrap.innerHTML = `
            <div>
              <label for="bviId">BVI ID *</label>
              <input id="bviId" placeholder="263" value="${state.inputs.bviId || ""}" />
              <div class="error" data-error-for="bviId"></div>
            </div>
            <div class="helper">Optional. Provide BVI ID to enable the Step 5 command.</div>
          `;
          card.insertBefore(bviWrap, commandText);
        }

        if (command.id === 3 && state.inputs.aggVendor === "Huawei") {
          const interfaceWrap = document.createElement("div");
          interfaceWrap.className = "progressive-fields";
          interfaceWrap.innerHTML = `
            <div>
              <label for="huaweiInterface">Interface (Eth-Trunk) *</label>
              <input id="huaweiInterface" placeholder="Eth-Trunk7" value="${state.inputs.interfaceName || ""}" />
              <div class="helper">Required to unlock Step 3 for Huawei.</div>
            </div>
          `;
          card.insertBefore(interfaceWrap, commandText);
        }

        if (state.inputs.aggVendor === "Cisco" && determineLayer() === "L2") {
          if (command.id === 3) {
            const bdWrap = document.createElement("div");
            bdWrap.className = "progressive-fields";
            bdWrap.dataset.l2Bd = "true";
            bdWrap.style.display = state.progress.revealL2Bd ? "grid" : "none";
            bdWrap.innerHTML = `
              <div>
                <label for="bridgeGroup">Bridge Group *</label>
                <input id="bridgeGroup" placeholder="BG-EXAMPLE" value="${state.inputs.bridgeGroup || ""}" />
              </div>
              <div>
                <label for="bridgeDomain">Bridge Domain *</label>
                <input id="bridgeDomain" placeholder="BD-EXAMPLE" value="${state.inputs.bridgeDomain || ""}" />
                <div class="helper">Required to unlock Step 4.</div>
              </div>
            `;
            card.appendChild(bdWrap);
          }
          if (command.id === 4) {
            const cpuWrap = document.createElement("div");
            cpuWrap.className = "progressive-fields";
            cpuWrap.dataset.l2Cpu = "true";
            cpuWrap.style.display = state.progress.revealL2Bd && state.inputs.bridgeGroup && state.inputs.bridgeDomain ? "grid" : "none";
            const cpuChoice = state.inputs.cpuLocationChoice;
            const cpuManual = state.inputs.cpuLocationManual || "";
            const manualSelected = cpuChoice === "manual" || (!cpuChoice && cpuManual);
            cpuWrap.innerHTML = `
              <div>
                <label for="cpuLocationSelect">MAC Location *</label>
                <select id="cpuLocationSelect">
                  <option value="">Select</option>
                  <option value="unknown" ${cpuChoice === "unknown" ? "selected" : ""}>I don't know</option>
                  <option value="manual" ${manualSelected ? "selected" : ""}>Manual entry</option>
                </select>
                <div class="helper">Required for MAC table check.</div>
              </div>
              <div id="cpuLocationManualField" style="display: ${manualSelected ? "block" : "none"};">
                <label for="cpuLocationManual">Manual Location</label>
                <input id="cpuLocationManual" placeholder="0/0/cPU0" value="${cpuManual}" />
              </div>
            `;
            card.appendChild(cpuWrap);
          }
        }

        runner.appendChild(card);
      });

      wireProgressiveInputs();
    }

    function wireProgressiveInputs() {
      const bridgeGroupEl = document.getElementById("bridgeGroup");
      const bridgeDomainEl = document.getElementById("bridgeDomain");
      const bviEl = document.getElementById("bviId");
      const huaweiInterfaceEl = document.getElementById("huaweiInterface");
      const cpuLocationSelectEl = document.getElementById("cpuLocationSelect");
      const cpuLocationManualEl = document.getElementById("cpuLocationManual");

      if (bridgeGroupEl) {
        bridgeGroupEl.addEventListener("input", () => {
          state.inputs.bridgeGroup = bridgeGroupEl.value.trim();
          updateCommandRunnerStates();
        });
      }
      if (bridgeDomainEl) {
        bridgeDomainEl.addEventListener("input", () => {
          state.inputs.bridgeDomain = bridgeDomainEl.value.trim();
          updateCommandRunnerStates();
        });
      }
      if (bviEl) {
        bviEl.addEventListener("input", () => {
          state.inputs.bviId = bviEl.value.trim();
          updateCommandRunnerStates();
        });
      }
      if (huaweiInterfaceEl) {
        huaweiInterfaceEl.addEventListener("input", () => {
          state.inputs.interfaceName = huaweiInterfaceEl.value.trim();
          updateCommandRunnerStates();
        });
      }
      if (cpuLocationSelectEl) {
        cpuLocationSelectEl.addEventListener("change", () => {
          state.inputs.cpuLocationChoice = cpuLocationSelectEl.value;
          updateCommandRunnerStates();
        });
      }
      if (cpuLocationManualEl) {
        cpuLocationManualEl.addEventListener("input", () => {
          state.inputs.cpuLocationManual = cpuLocationManualEl.value.trim();
          updateCommandRunnerStates();
        });
      }
    }

    function updateCommandRunnerStates() {
      const commands = buildCommandModel();
      commands.forEach(command => {
        const card = document.querySelector(`[data-command-id="${command.id}"]`);
        if (!card) return;
        const statusInfo = isLocked(command);
        const isCopied = state.progress.copied[command.id];
        card.classList.toggle("locked", statusInfo.locked);

        const statusEl = card.querySelector(".status");
        if (statusEl) {
          statusEl.className = `status ${isCopied ? "copied" : statusInfo.locked ? "locked" : "ready"}`;
          statusEl.textContent = isCopied ? "Copied ✓" : statusInfo.locked ? "Locked" : "Ready";
        }

        const commandText = card.querySelector(".command-text");
        if (commandText) {
          commandText.textContent = command.template;
        }

        const copyButton = card.querySelector("button");
        if (copyButton) {
          copyButton.disabled = statusInfo.locked;
        }

        const statusText = card.querySelector(".small-tag");
        if (statusText) {
          statusText.textContent = statusInfo.locked ? statusInfo.reason : "Command ready to copy.";
        }

        const l2BdWrap = card.querySelector("[data-l2-bd]");
        if (l2BdWrap) {
          l2BdWrap.style.display = state.progress.revealL2Bd ? "grid" : "none";
        }

        const l2CpuWrap = card.querySelector("[data-l2-cpu]");
        if (l2CpuWrap) {
          l2CpuWrap.style.display = state.progress.revealL2Bd && state.inputs.bridgeGroup && state.inputs.bridgeDomain ? "grid" : "none";
          const cpuSelect = l2CpuWrap.querySelector("#cpuLocationSelect");
          const cpuManualField = l2CpuWrap.querySelector("#cpuLocationManualField");
          const cpuManualInput = l2CpuWrap.querySelector("#cpuLocationManual");
          if (cpuSelect) {
            const choice = state.inputs.cpuLocationChoice;
            cpuSelect.value = choice || "";
            if (!choice && state.inputs.cpuLocationManual) {
              cpuSelect.value = "manual";
            }
          }
          if (cpuManualField) {
            const showManual = state.inputs.cpuLocationChoice === "manual";
            cpuManualField.style.display = showManual ? "block" : "none";
          }
          if (cpuManualInput) {
            cpuManualInput.value = state.inputs.cpuLocationManual || "";
          }
        }

      });
    }

    function handleCopy(stepId, commandText) {
      navigator.clipboard.writeText(commandText).then(() => {
        state.progress.copied[stepId] = true;
        if (stepId === 3 && state.inputs.aggVendor === "Cisco" && determineLayer() === "L3") {
          state.progress.revealBridge = true;
        }
        if (stepId === 3 && state.inputs.aggVendor === "Cisco" && determineLayer() === "L2") {
          state.progress.revealL2Bd = true;
        }
        if (stepId === 4) {
          state.progress.copied[4] = true;
        }
        renderCommandRunner(buildCommandModel());
      }).catch(() => {
        const textarea = document.createElement("textarea");
        textarea.value = commandText;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        state.progress.copied[stepId] = true;
        if (stepId === 3 && state.inputs.aggVendor === "Cisco" && determineLayer() === "L3") {
          state.progress.revealBridge = true;
        }
        if (stepId === 3 && state.inputs.aggVendor === "Cisco" && determineLayer() === "L2") {
          state.progress.revealL2Bd = true;
        }
        renderCommandRunner(buildCommandModel());
      });
    }

    function renderLayerSection() {
      const layerInfo = document.getElementById("layerInfo");
      const override = document.getElementById("layerOverride");
      if (!state.derived.inferredLayer) {
        layerInfo.textContent = "Layer will be inferred from the circuit token.";
        override.style.display = "none";
        return;
      }
      if (state.derived.inferredLayer === "UNKNOWN") {
        layerInfo.textContent = "Service token not recognized. Select a manual layer override.";
        override.style.display = "flex";
      } else {
        layerInfo.textContent = `Inferred Layer: ${state.derived.inferredLayer}.`;
        override.style.display = "none";
      }
    }

    function updateVrfLabel() {
      const label = document.getElementById("vrfLabel");
      const labelText = document.getElementById("vrfLabelText");
      if (state.inputs.aggVendor === "Huawei") {
        label.textContent = "Huawei: VPN Instance";
        if (labelText) labelText.textContent = "VPN Instance *";
      } else if (state.inputs.aggVendor === "Juniper") {
        label.textContent = "Juniper: Routing Instance";
        if (labelText) labelText.textContent = "Routing Instance *";
      } else {
        label.textContent = "Cisco: VRF Name";
        if (labelText) labelText.textContent = "VRF Name *";
      }
    }

    function toggleUpeFields() {
      const showUpe = state.inputs.transportType === "UPE";
      const upeNameField = document.getElementById("upeNameField");
      const upeVendorField = document.getElementById("upeVendorField");
      if (upeNameField) upeNameField.style.display = showUpe ? "block" : "none";
      if (upeVendorField) upeVendorField.style.display = showUpe ? "block" : "none";
      if (!showUpe) {
        state.inputs.upeName = "";
        state.inputs.upeVendor = "";
        const upeNameInput = document.getElementById("upeName");
        const upeVendorInput = document.getElementById("upeVendor");
        if (upeNameInput) upeNameInput.value = "";
        if (upeVendorInput) upeVendorInput.value = "";
        setError("upeName", "");
        setError("upeVendor", "");
      }
    }

    function toggleInterfaceField() {
      const interfaceField = document.getElementById("interfaceField");
      if (!interfaceField) return;
      const hideInterface = state.inputs.aggVendor === "Huawei" || state.inputs.aggVendor === "Juniper";
      interfaceField.style.display = hideInterface ? "none" : "block";
      if (hideInterface) {
        const interfaceInput = document.getElementById("interfaceName");
        if (interfaceInput) interfaceInput.value = "";
        state.inputs.interfaceName = "";
      }
    }

    function toggleJuniperFields() {
      const layer = determineLayer();
      const isJuniperL3 = state.inputs.aggVendor === "Juniper" && layer === "L3";
      const placementField = document.getElementById("juniperFields");
      const ifaceField = document.getElementById("juniperIfaceField");
      const irbField = document.getElementById("juniperIrbField");
      if (placementField) placementField.style.display = isJuniperL3 ? "block" : "none";
      if (!isJuniperL3) {
        if (ifaceField) ifaceField.style.display = "none";
        if (irbField) irbField.style.display = "none";
        return;
      }
      const placement = state.inputs.juniperPlacement;
      if (ifaceField) ifaceField.style.display = placement === "vlan" ? "block" : "none";
      if (irbField) irbField.style.display = placement === "irb" ? "block" : "none";
    }

    function renderNotImplemented(layer) {
      const container = document.getElementById("notImplemented");
      const supported = (state.inputs.aggVendor === "Cisco" && (layer === "L3" || layer === "L2"))
        || (state.inputs.aggVendor === "Huawei" && layer === "L3")
        || (state.inputs.aggVendor === "Juniper" && layer === "L3");
      if (state.inputs.aggVendor && layer && !supported) {
        container.style.display = "block";
        container.textContent = `Template not yet implemented for: ${state.inputs.aggVendor} + ${layer}. MVP currently supports Cisco Layer 2 and Cisco/Huawei/Juniper Layer 3.`;
      } else {
        container.style.display = "none";
        container.textContent = "";
      }
    }

    function buildRunner() {
      const validation = validateAll();
      updateDerived();
      renderLayerSection();
      updateVrfLabel();
      toggleUpeFields();
      toggleInterfaceField();
      toggleJuniperFields();
      renderSummary();

      const layer = determineLayer();
      renderNotImplemented(layer);

      if (!validation.isValid) {
        renderCommandRunner([]);
        document.getElementById("download").disabled = true;
        document.getElementById("escalationNote").style.display = "none";
        return;
      }

      const supported = (state.inputs.aggVendor === "Cisco" && (layer === "L3" || layer === "L2"))
        || (state.inputs.aggVendor === "Huawei" && layer === "L3")
        || (state.inputs.aggVendor === "Juniper" && layer === "L3");
      if (!supported) {
        renderCommandRunner([]);
        document.getElementById("download").disabled = true;
        document.getElementById("escalationNote").style.display = "none";
        return;
      }

      const commands = buildCommandModel();
      renderCommandRunner(commands);
      document.getElementById("download").disabled = false;
      const escalationNote = document.getElementById("escalationNote");
      if (state.inputs.aggVendor === "Huawei" && layer === "L3") {
        escalationNote.textContent = "Escalation condition: If VLANIF missing, MAC absent, policy not allowing VLAN, ping fails, or BGP peer not Established \u2192 escalate to Activation.";
        escalationNote.style.display = "block";
      } else {
        escalationNote.style.display = "none";
      }
    }

    function resetForm() {
      document.querySelectorAll("input, select").forEach(el => {
        if (el.type === "radio") {
          el.checked = false;
        } else {
          el.value = "";
        }
      });
      state.inputs = {
        circuitName: "",
        orderType: "",
        transportType: "",
        aggregatorPe: "",
        upeName: "",
        vlanId: "",
        interfaceName: "",
        aggVendor: "",
        upeVendor: "",
        customerIp: "",
        defaultGateway: "",
        vrfName: "",
        juniperPlacement: "",
        juniperIfaceBase: "",
        irbUnitId: "",
        layerChoice: "",
        bridgeGroup: "",
        bridgeDomain: "",
        cpuLocationChoice: "",
        cpuLocationManual: "",
        bviId: ""
      };
      state.derived = { parsedCircuit: null, inferredLayer: "", layerSource: "" };
      state.progress = { copied: {}, revealBridge: false, revealL2Bd: false };
      fieldIds.forEach(field => setError(field, ""));
      setError("layerChoice", "");
      renderSummary();
      renderCommandRunner([]);
      renderLayerSection();
      updateVrfLabel();
      toggleUpeFields();
      toggleInterfaceField();
      toggleJuniperFields();
      document.getElementById("download").disabled = true;
    }

    function downloadCommands() {
      const commands = buildCommandModel();
      const lines = commands.map(cmd => cmd.template).join("\n");
      const blob = new Blob([lines], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "verification-commands.txt";
      link.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById("generate").addEventListener("click", buildRunner);
    document.getElementById("reset").addEventListener("click", resetForm);
    document.getElementById("download").addEventListener("click", downloadCommands);

    document.querySelectorAll("input, select").forEach(el => {
      if (el.id === "generate" || el.id === "reset" || el.id === "download") return;
      el.addEventListener("input", () => {
        if (el.id === "circuitName") {
          const start = el.selectionStart;
          el.value = el.value.toUpperCase();
          el.setSelectionRange(start, start);
          updateDerived();
          renderLayerSection();
        }
        updateVrfLabel();
        if (el.id === "transportType") {
          syncInputs();
          toggleUpeFields();
        }
        if (el.id === "aggVendor") {
          syncInputs();
          toggleInterfaceField();
          updateVrfLabel();
          toggleJuniperFields();
        }
        if (el.id === "juniperPlacement") {
          syncInputs();
          toggleJuniperFields();
        }
      });
      el.addEventListener("change", () => {
        if (el.name === "layerChoice") {
          state.inputs.layerChoice = el.value;
        }
        updateVrfLabel();
        if (el.id === "transportType") {
          syncInputs();
          toggleUpeFields();
        }
        if (el.id === "aggVendor") {
          syncInputs();
          toggleInterfaceField();
          updateVrfLabel();
          toggleJuniperFields();
        }
        if (el.id === "juniperPlacement") {
          syncInputs();
          toggleJuniperFields();
        }
      });
    });

    renderSummary();
    renderCommandRunner([]);
    toggleUpeFields();
    toggleInterfaceField();
    toggleJuniperFields();
  </script>
</body>
</html>
