<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STC Circuit Assurance</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f7f8fb;
      --card: #ffffff;
      --border: #d9dde6;
      --text: #1b2430;
      --muted: #5b677a;
      --primary: #4f008c;
      --accent: #ff375e;
      --success: #1f9254;
      --warning: #d9822b;
      --danger: #c0342f;
      --lock: #8d99ae;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 24px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }

    p.lead {
      margin: 0 0 20px;
      color: var(--muted);
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(24, 32, 50, 0.08);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 0.9rem;
    }

    input, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
    }

    input:focus, select:focus {
      outline: 2px solid rgba(79, 0, 140, 0.25);
      border-color: var(--primary);
    }

    .helper {
      color: var(--muted);
      font-size: 0.8rem;
      margin-top: 4px;
    }

    .error {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 4px;
    }

    .inline {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid transparent;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: white;
    }

    button:hover:not(:disabled) {
      background: #3c006b;
    }

    button.secondary {
      background: white;
      border-color: var(--border);
      color: var(--text);
    }

    button.secondary:hover:not(:disabled) {
      border-color: var(--primary);
      color: var(--primary);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    .summary-item {
      padding: 10px 12px;
      border-radius: 8px;
      background: #f0f3fa;
      font-size: 0.85rem;
    }

    .summary-item strong {
      display: block;
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .command-list {
      display: grid;
      gap: 12px;
    }

    .command-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px 14px;
      display: grid;
      gap: 10px;
    }

    .command-card.locked {
      background: #f8f9fc;
      border-style: dashed;
      color: var(--lock);
    }

    .command-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .status {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      padding: 4px 8px;
      border-radius: 999px;
    }

    .status.ready {
      background: rgba(79, 0, 140, 0.12);
      color: var(--primary);
    }

    .status.locked {
      background: rgba(141, 153, 174, 0.2);
      color: var(--lock);
    }

    .status.copied {
      background: rgba(255, 55, 94, 0.18);
      color: var(--accent);
    }

    .command-text {
      font-family: var(--mono);
      font-size: 0.95rem;
      padding: 10px 12px;
      background: #f3f4f8;
      border-radius: 8px;
      overflow-x: auto;
    }

    .locked-message {
      font-size: 0.85rem;
      color: var(--lock);
    }

    .progressive-fields {
      display: grid;
      gap: 12px;
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed var(--border);
      background: #fbfbfd;
    }

    .small-tag {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .not-implemented {
      border-left: 4px solid var(--accent);
      background: #fff7ed;
      color: #7a4c1b;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      margin-top: 10px;
    }

    @media (max-width: 600px) {
      body {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>STC Circuit Assurance</h1>
    <p class="lead">Operational checks made simple—copy one command at a time.</p>

    <div class="card">
      <h2>Inputs</h2>
      <div class="form-grid">
        <div>
          <label for="circuitName">Circuit Name *</label>
          <input id="circuitName" placeholder="JEDDAH-MAKKAH IP263" />
          <div class="helper">Format: &lt;SITE-A&gt;-&lt;SITE-Z&gt; &lt;TYPE&gt;&lt;ID&gt;</div>
          <div class="error" data-error-for="circuitName"></div>
        </div>
        <div>
          <label for="orderType">Order Type *</label>
          <select id="orderType">
            <option value="">Select</option>
            <option value="I">I</option>
            <option value="M">M</option>
            <option value="C">C</option>
            <option value="O">O</option>
          </select>
          <div class="error" data-error-for="orderType"></div>
        </div>
        <div>
          <label for="transportType">Transport Type *</label>
          <select id="transportType">
            <option value="">Select</option>
            <option value="Fiber">Fiber</option>
            <option value="Copper">Copper</option>
            <option value="Transmission">Transmission</option>
            <option value="UPE">UPE</option>
          </select>
          <div class="error" data-error-for="transportType"></div>
        </div>
        <div>
          <label for="aggregatorPe">Aggregator PE Name *</label>
          <input id="aggregatorPe" placeholder="AGG-PE-01" />
          <div class="error" data-error-for="aggregatorPe"></div>
        </div>
        <div id="upeNameField" style="display: none;">
          <label for="upeName">UPE Name (required if UPE)</label>
          <input id="upeName" placeholder="UPE-01" />
          <div class="error" data-error-for="upeName"></div>
        </div>
        <div>
          <label for="vlanId">VLAN ID *</label>
          <input id="vlanId" type="number" min="1" max="4094" />
          <div class="error" data-error-for="vlanId"></div>
        </div>
        <div>
          <label for="interfaceName">Interface (optional)</label>
          <input id="interfaceName" placeholder="Bundle-Ether10.263" />
          <div class="helper">Required to unlock interface-dependent commands.</div>
        </div>
        <div>
          <label for="aggVendor">Aggregator PE Vendor *</label>
          <select id="aggVendor">
            <option value="">Select</option>
            <option value="Cisco">Cisco</option>
            <option value="Huawei">Huawei</option>
            <option value="Juniper">Juniper</option>
          </select>
          <div class="error" data-error-for="aggVendor"></div>
        </div>
        <div id="upeVendorField" style="display: none;">
          <label for="upeVendor">UPE Vendor (required if UPE)</label>
          <select id="upeVendor">
            <option value="">Select</option>
            <option value="Cisco">Cisco</option>
            <option value="Huawei">Huawei</option>
            <option value="Juniper">Juniper</option>
          </select>
          <div class="error" data-error-for="upeVendor"></div>
        </div>
        <div>
          <label for="customerIp">Customer IP (Layer 3) *</label>
          <input id="customerIp" placeholder="192.0.2.10" />
          <div class="error" data-error-for="customerIp"></div>
        </div>
        <div>
          <label for="defaultGateway">Default Gateway (Layer 3) *</label>
          <input id="defaultGateway" placeholder="192.0.2.1" />
          <div class="error" data-error-for="defaultGateway"></div>
        </div>
        <div>
          <label for="vrfName">Routing Context (Layer 3) *</label>
          <input id="vrfName" placeholder="VRF-Example" />
          <div class="helper" id="vrfLabel">Cisco: VRF Name</div>
          <div class="error" data-error-for="vrfName"></div>
        </div>
      </div>
      <div class="card" style="margin-top: 16px;">
        <h2>Layer Determination</h2>
        <div id="layerInfo" class="helper">Layer is inferred from circuit token.</div>
        <div id="layerOverride" class="inline" style="margin-top: 10px; display: none;">
          <strong>Manual Override:</strong>
          <label><input type="radio" name="layerChoice" value="L2"> Layer 2</label>
          <label><input type="radio" name="layerChoice" value="L3"> Layer 3</label>
        </div>
        <div class="error" data-error-for="layerChoice"></div>
      </div>
      <div class="buttons" style="margin-top: 16px;">
        <button id="generate">Build Command Runner</button>
        <button id="reset" class="secondary">Reset Form</button>
        <button id="download" class="secondary" disabled>Download All Commands (.txt)</button>
      </div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Classification Summary</h2>
      <div id="summary" class="summary-grid"></div>
      <div id="notImplemented" class="not-implemented" style="display: none;"></div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Command Runner</h2>
      <div id="commandRunner" class="command-list"></div>
    </div>
  </div>

  <script>
    const state = {
      inputs: {
        circuitName: "",
        orderType: "",
        transportType: "",
        aggregatorPe: "",
        upeName: "",
        vlanId: "",
        interfaceName: "",
        aggVendor: "",
        upeVendor: "",
        customerIp: "",
        defaultGateway: "",
        vrfName: "",
        layerChoice: "",
        bridgeGroup: "",
        bridgeDomain: "",
        bviId: ""
      },
      derived: {
        parsedCircuit: null,
        inferredLayer: "",
        layerSource: ""
      },
      progress: {
        copied: {},
        revealBridge: false
      }
    };

    const fieldIds = Object.keys(state.inputs);

    function parseCircuitName(value) {
      if (!value) return null;
      const cleaned = value.trim().toUpperCase();
      const match = cleaned.match(/^([A-Z0-9]+)-([A-Z0-9]+)\s+([A-Z]+)(\d+)$/);
      if (!match) return null;
      return {
        siteA: match[1],
        siteZ: match[2],
        serviceToken: match[3],
        serviceId: match[4],
        fullToken: `${match[3]}${match[4]}`
      };
    }

    function inferLayer(serviceToken) {
      if (!serviceToken) return "";
      const token = serviceToken.toUpperCase();
      if (["IP", "SIP"].includes(token)) return "L3";
      if (["DIA", "DIAS", "PLL", "DLL", "MDIA"].includes(token)) return "L2";
      return "UNKNOWN";
    }

    function validateIPv4(value) {
      const parts = value.trim().split(".");
      if (parts.length !== 4) return false;
      return parts.every(part => {
        if (!/^\d+$/.test(part)) return false;
        const num = Number(part);
        return num >= 0 && num <= 255;
      });
    }

    function setError(field, message) {
      const el = document.querySelector(`[data-error-for="${field}"]`);
      if (el) {
        el.textContent = message || "";
      }
    }

    function syncInputs() {
      fieldIds.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        state.inputs[id] = el.value.trim();
      });
      const choice = document.querySelector('input[name="layerChoice"]:checked');
      state.inputs.layerChoice = choice ? choice.value : "";
    }

    function updateDerived() {
      const parsed = parseCircuitName(state.inputs.circuitName);
      state.derived.parsedCircuit = parsed;
      if (parsed) {
        const inferred = inferLayer(parsed.serviceToken);
        state.derived.inferredLayer = inferred;
      } else {
        state.derived.inferredLayer = "";
      }
    }

    function determineLayer() {
      if (state.derived.inferredLayer && state.derived.inferredLayer !== "UNKNOWN") {
        state.derived.layerSource = "inferred";
        return state.derived.inferredLayer;
      }
      if (state.derived.inferredLayer === "UNKNOWN" && state.inputs.layerChoice) {
        state.derived.layerSource = "manual";
        return state.inputs.layerChoice;
      }
      return "";
    }

    function validateAll() {
      syncInputs();
      updateDerived();
      const errors = {};
      if (!state.inputs.circuitName) {
        errors.circuitName = "Circuit name is required.";
      } else if (!state.derived.parsedCircuit) {
        errors.circuitName = "Circuit name format is invalid.";
      }

      if (!state.inputs.orderType) {
        errors.orderType = "Order type is required.";
      }
      if (!state.inputs.transportType) {
        errors.transportType = "Transport type is required.";
      }
      const needsAgg = ["Fiber", "Copper", "Transmission", "UPE"].includes(state.inputs.transportType);
      if (needsAgg && !state.inputs.aggregatorPe) {
        errors.aggregatorPe = "Aggregator PE name is required.";
      }
      if (state.inputs.transportType === "UPE" && !state.inputs.upeName) {
        errors.upeName = "UPE name is required for UPE transport.";
      }
      const vlan = Number(state.inputs.vlanId);
      if (!state.inputs.vlanId) {
        errors.vlanId = "VLAN ID is required.";
      } else if (!Number.isInteger(vlan) || vlan < 1 || vlan > 4094) {
        errors.vlanId = "VLAN must be between 1 and 4094.";
      }
      if (!state.inputs.aggVendor) {
        errors.aggVendor = "Aggregator PE vendor is required.";
      }
      if (state.inputs.transportType === "UPE" && !state.inputs.upeVendor) {
        errors.upeVendor = "UPE vendor is required for UPE transport.";
      }

      const layer = determineLayer();
      if (!layer) {
        errors.layerChoice = "Layer cannot be determined. Select a manual override.";
      }

      if (layer === "L3") {
        if (!state.inputs.customerIp) {
          errors.customerIp = "Customer IP is required for Layer 3.";
        } else if (!validateIPv4(state.inputs.customerIp)) {
          errors.customerIp = "Customer IP must be a valid IPv4 address.";
        }
        if (!state.inputs.defaultGateway) {
          errors.defaultGateway = "Default gateway is required for Layer 3.";
        } else if (!validateIPv4(state.inputs.defaultGateway)) {
          errors.defaultGateway = "Default gateway must be a valid IPv4 address.";
        }
        if (!state.inputs.vrfName) {
          errors.vrfName = "Routing context name is required for Layer 3.";
        }
      }

      fieldIds.forEach(field => setError(field, ""));
      setError("layerChoice", "");
      Object.entries(errors).forEach(([field, message]) => setError(field, message));

      return {
        isValid: Object.keys(errors).length === 0,
        errors
      };
    }

    function buildCommandModel() {
      const parsed = state.derived.parsedCircuit;
      if (!parsed) return [];
      const fullToken = parsed.fullToken;
      const interfaceName = state.inputs.interfaceName;
      const vrf = state.inputs.vrfName;
      const customerIp = state.inputs.customerIp;
      const bridgeGroup = state.inputs.bridgeGroup || "";
      const bridgeDomain = state.inputs.bridgeDomain || "";
      const bviId = state.inputs.bviId || "";
      const aggregatorPe = state.inputs.aggregatorPe || "";

      return [
        {
          id: 0,
          label: "Step 0",
          template: aggregatorPe ? `connect ${aggregatorPe}` : "connect Aggregator PE Name *",
          requires: ["aggregator"]
        },
        {
          id: 1,
          label: "Step 1",
          template: `sh int desc | i ${fullToken}`,
          requires: []
        },
        {
          id: 2,
          label: "Step 2",
          template: interfaceName ? `sh run int ${interfaceName}` : "sh run int <INTERFACE>",
          requires: ["interface"]
        },
        {
          id: 3,
          label: "Step 3",
          template: interfaceName
            ? `sh l2vpn bridge-domain interface ${interfaceName} brief`
            : "sh l2vpn bridge-domain interface <INTERFACE> brief",
          requires: ["interface"]
        },
        {
          id: 4,
          label: "Step 4",
          template: bridgeGroup && bridgeDomain
            ? `sh run l2vpn bridge group ${bridgeGroup} bridge-domain ${bridgeDomain}`
            : "sh run l2vpn bridge group <BRIDGE_GROUP> bridge-domain <BRIDGE_DOMAIN>",
          requires: ["bridge"]
        },
        {
          id: 5,
          label: "Step 5",
          template: bviId ? `sh run int BVI${bviId}` : "sh run int BVI<BVI_ID>",
          requires: ["bvi"]
        },
        {
          id: 6,
          label: "Step 6",
          template: vrf && customerIp
            ? `sh arp vrf ${vrf} ${customerIp}`
            : "sh arp vrf <VRF> <CUSTOMER_IP>",
          requires: ["vrf"]
        },
        {
          id: 7,
          label: "Step 7",
          template: vrf && customerIp
            ? `ping vrf ${vrf} ${customerIp} count 100`
            : "ping vrf <VRF> <CUSTOMER_IP> count 100",
          requires: ["vrf"]
        },
        {
          id: 8,
          label: "Step 8",
          template: vrf && customerIp
            ? `show bgp vrf ${vrf} summary | i ${customerIp}`
            : "show bgp vrf <VRF> summary | i <CUSTOMER_IP>",
          requires: ["vrf"]
        }
      ];
    }

    function isLocked(command) {
      if (command.requires.includes("aggregator") && !state.inputs.aggregatorPe) {
        return { locked: true, reason: "Aggregator PE name is required to unlock this command." };
      }
      if (command.requires.includes("interface") && !state.inputs.interfaceName) {
        return { locked: true, reason: "Interface not provided — add interface to unlock this command." };
      }
      if (command.requires.includes("bridge")) {
        if (!state.inputs.bridgeGroup || !state.inputs.bridgeDomain) {
          return { locked: true, reason: "Provide Bridge Group + Bridge Domain to unlock." };
        }
      }
      if (command.requires.includes("bvi") && !state.inputs.bviId) {
        return { locked: true, reason: "Optional: provide BVI ID to unlock this command." };
      }
      if (command.requires.includes("vrf")) {
        if (!state.inputs.vrfName || !state.inputs.customerIp) {
          return { locked: true, reason: "Provide VRF and Customer IP to unlock." };
        }
      }
      return { locked: false, reason: "" };
    }

    function renderSummary() {
      const parsed = state.derived.parsedCircuit;
      const layer = determineLayer();
      const summary = document.getElementById("summary");
      summary.innerHTML = "";
      const items = [
        { label: "Layer", value: layer || "—" },
        { label: "Order Type", value: state.inputs.orderType || "—" },
        { label: "Transport", value: state.inputs.transportType || "—" },
        { label: "Aggregator Vendor", value: state.inputs.aggVendor || "—" },
        { label: "UPE Vendor", value: state.inputs.upeVendor || "—" },
        { label: "Sites", value: parsed ? `${parsed.siteA} ↔ ${parsed.siteZ}` : "—" },
        { label: "Circuit Token", value: parsed ? parsed.fullToken : "—" },
        { label: "VLAN", value: state.inputs.vlanId || "—" },
        { label: "VRF", value: state.inputs.vrfName || "—" }
      ];
      items.forEach(item => {
        const div = document.createElement("div");
        div.className = "summary-item";
        div.innerHTML = `<strong>${item.label}</strong>${item.value}`;
        summary.appendChild(div);
      });
    }

    function renderCommandRunner(commands) {
      const runner = document.getElementById("commandRunner");
      runner.innerHTML = "";

      if (!commands.length) {
        runner.innerHTML = "<div class='helper'>No commands available yet. Build the runner after completing required inputs.</div>";
        return;
      }

      commands.forEach(command => {
        const statusInfo = isLocked(command);
        const isCopied = state.progress.copied[command.id];
        const card = document.createElement("div");
        card.className = `command-card ${statusInfo.locked ? "locked" : ""}`;

        const header = document.createElement("div");
        header.className = "command-header";
        header.innerHTML = `
          <div><strong>${command.label}</strong></div>
          <div class="status ${isCopied ? "copied" : statusInfo.locked ? "locked" : "ready"}">
            ${isCopied ? "Copied ✓" : statusInfo.locked ? "Locked" : "Ready"}
          </div>
        `;

        const commandText = document.createElement("div");
        commandText.className = "command-text";
        commandText.textContent = command.template;

        const footer = document.createElement("div");
        footer.className = "inline";

        const copyButton = document.createElement("button");
        copyButton.textContent = "Copy";
        copyButton.disabled = statusInfo.locked;
        copyButton.addEventListener("click", () => handleCopy(command.id, command.template));

        const statusText = document.createElement("span");
        statusText.className = "small-tag";
        statusText.textContent = statusInfo.locked ? statusInfo.reason : "Command ready to copy.";

        footer.appendChild(copyButton);
        footer.appendChild(statusText);

        card.appendChild(header);
        card.appendChild(commandText);
        card.appendChild(footer);

        if (command.id === 3 && state.progress.revealBridge) {
          const bridgeWrap = document.createElement("div");
          bridgeWrap.className = "progressive-fields";
          bridgeWrap.innerHTML = `
            <div>
              <label for="bridgeGroup">Bridge Group *</label>
              <input id="bridgeGroup" placeholder="BG-EXAMPLE" value="${state.inputs.bridgeGroup || ""}" />
              <div class="error" data-error-for="bridgeGroup"></div>
            </div>
            <div>
              <label for="bridgeDomain">Bridge Domain *</label>
              <input id="bridgeDomain" placeholder="BD-EXAMPLE" value="${state.inputs.bridgeDomain || ""}" />
              <div class="error" data-error-for="bridgeDomain"></div>
            </div>
          `;
          card.appendChild(bridgeWrap);
        }

        if (command.id === 5) {
          const bviWrap = document.createElement("div");
          bviWrap.className = "progressive-fields";
          bviWrap.innerHTML = `
            <div>
              <label for="bviId">BVI ID *</label>
              <input id="bviId" placeholder="263" value="${state.inputs.bviId || ""}" />
              <div class="error" data-error-for="bviId"></div>
            </div>
            <div class="helper">Optional. Provide BVI ID to enable the Step 5 command.</div>
          `;
          card.insertBefore(bviWrap, commandText);
        }

        runner.appendChild(card);
      });

      wireProgressiveInputs();
    }

    function wireProgressiveInputs() {
      const bridgeGroupEl = document.getElementById("bridgeGroup");
      const bridgeDomainEl = document.getElementById("bridgeDomain");
      const bviEl = document.getElementById("bviId");

      if (bridgeGroupEl) {
        bridgeGroupEl.addEventListener("input", () => {
          state.inputs.bridgeGroup = bridgeGroupEl.value.trim();
          renderCommandRunner(buildCommandModel());
        });
      }
      if (bridgeDomainEl) {
        bridgeDomainEl.addEventListener("input", () => {
          state.inputs.bridgeDomain = bridgeDomainEl.value.trim();
          renderCommandRunner(buildCommandModel());
        });
      }
      if (bviEl) {
        bviEl.addEventListener("input", () => {
          state.inputs.bviId = bviEl.value.trim();
          renderCommandRunner(buildCommandModel());
        });
      }
    }

    function handleCopy(stepId, commandText) {
      navigator.clipboard.writeText(commandText).then(() => {
        state.progress.copied[stepId] = true;
        if (stepId === 3) {
          state.progress.revealBridge = true;
        }
        if (stepId === 4) {
          state.progress.copied[4] = true;
        }
        renderCommandRunner(buildCommandModel());
      }).catch(() => {
        const textarea = document.createElement("textarea");
        textarea.value = commandText;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        state.progress.copied[stepId] = true;
        if (stepId === 3) {
          state.progress.revealBridge = true;
        }
        renderCommandRunner(buildCommandModel());
      });
    }

    function renderLayerSection() {
      const layerInfo = document.getElementById("layerInfo");
      const override = document.getElementById("layerOverride");
      if (!state.derived.inferredLayer) {
        layerInfo.textContent = "Layer will be inferred from the circuit token.";
        override.style.display = "none";
        return;
      }
      if (state.derived.inferredLayer === "UNKNOWN") {
        layerInfo.textContent = "Service token not recognized. Select a manual layer override.";
        override.style.display = "flex";
      } else {
        layerInfo.textContent = `Inferred Layer: ${state.derived.inferredLayer}.`;
        override.style.display = "none";
      }
    }

    function updateVrfLabel() {
      const label = document.getElementById("vrfLabel");
      if (state.inputs.aggVendor === "Huawei") {
        label.textContent = "Huawei: VPN Instance";
      } else if (state.inputs.aggVendor === "Juniper") {
        label.textContent = "Juniper: Routing Instance";
      } else {
        label.textContent = "Cisco: VRF Name";
      }
    }

    function toggleUpeFields() {
      const showUpe = state.inputs.transportType === "UPE";
      const upeNameField = document.getElementById("upeNameField");
      const upeVendorField = document.getElementById("upeVendorField");
      if (upeNameField) upeNameField.style.display = showUpe ? "block" : "none";
      if (upeVendorField) upeVendorField.style.display = showUpe ? "block" : "none";
      if (!showUpe) {
        state.inputs.upeName = "";
        state.inputs.upeVendor = "";
        const upeNameInput = document.getElementById("upeName");
        const upeVendorInput = document.getElementById("upeVendor");
        if (upeNameInput) upeNameInput.value = "";
        if (upeVendorInput) upeVendorInput.value = "";
        setError("upeName", "");
        setError("upeVendor", "");
      }
    }

    function renderNotImplemented(layer) {
      const container = document.getElementById("notImplemented");
      if (state.inputs.aggVendor && layer && !(state.inputs.aggVendor === "Cisco" && layer === "L3")) {
        container.style.display = "block";
        container.textContent = `Template not yet implemented for: ${state.inputs.aggVendor} + ${layer}. MVP currently supports Cisco Layer 3.`;
      } else {
        container.style.display = "none";
        container.textContent = "";
      }
    }

    function buildRunner() {
      const validation = validateAll();
      updateDerived();
      renderLayerSection();
      updateVrfLabel();
      toggleUpeFields();
      renderSummary();

      const layer = determineLayer();
      renderNotImplemented(layer);

      if (!validation.isValid) {
        renderCommandRunner([]);
        document.getElementById("download").disabled = true;
        return;
      }

      if (!(state.inputs.aggVendor === "Cisco" && layer === "L3")) {
        renderCommandRunner([]);
        document.getElementById("download").disabled = true;
        return;
      }

      const commands = buildCommandModel();
      renderCommandRunner(commands);
      document.getElementById("download").disabled = false;
    }

    function resetForm() {
      document.querySelectorAll("input, select").forEach(el => {
        if (el.type === "radio") {
          el.checked = false;
        } else {
          el.value = "";
        }
      });
      state.inputs = {
        circuitName: "",
        orderType: "",
        transportType: "",
        aggregatorPe: "",
        upeName: "",
        vlanId: "",
        interfaceName: "",
        aggVendor: "",
        upeVendor: "",
        customerIp: "",
        defaultGateway: "",
        vrfName: "",
        layerChoice: "",
        bridgeGroup: "",
        bridgeDomain: "",
        bviId: ""
      };
      state.derived = { parsedCircuit: null, inferredLayer: "", layerSource: "" };
      state.progress = { copied: {}, revealBridge: false };
      fieldIds.forEach(field => setError(field, ""));
      setError("layerChoice", "");
      renderSummary();
      renderCommandRunner([]);
      renderLayerSection();
      updateVrfLabel();
      toggleUpeFields();
      document.getElementById("download").disabled = true;
    }

    function downloadCommands() {
      const commands = buildCommandModel();
      const lines = commands.map(cmd => cmd.template).join("\n");
      const blob = new Blob([lines], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "verification-commands.txt";
      link.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById("generate").addEventListener("click", buildRunner);
    document.getElementById("reset").addEventListener("click", resetForm);
    document.getElementById("download").addEventListener("click", downloadCommands);

    document.querySelectorAll("input, select").forEach(el => {
      if (el.id === "generate" || el.id === "reset" || el.id === "download") return;
      el.addEventListener("input", () => {
        if (el.id === "circuitName") {
          updateDerived();
          renderLayerSection();
        }
        updateVrfLabel();
        if (el.id === "transportType") {
          syncInputs();
          toggleUpeFields();
        }
      });
      el.addEventListener("change", () => {
        if (el.name === "layerChoice") {
          state.inputs.layerChoice = el.value;
        }
        updateVrfLabel();
        if (el.id === "transportType") {
          syncInputs();
          toggleUpeFields();
        }
      });
    });

    renderSummary();
    renderCommandRunner([]);
    toggleUpeFields();
  </script>
</body>
</html>
